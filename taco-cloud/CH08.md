# 8. 비동기 메세지 전송하기
이전 장에서는 REST를 사용한 **동기화synchronous** 통신을 알아보았다. 이번 장에서는 **비동기asynchronous** 메세징을 배워볼 것이다. 비동기 메시징 처리는 애플리케이션 간 응답을 기다리지 않고 간접적으로 메시지를 전송하는 방법이다.

<br>

## 8.1 JMS로 메시지 전송하기
JMS는 두 개 이상의 클라이언트 간에 메시지 통신을 위한 공통 API를 정의하는 자바 표준이다. JMS가 나오기 전에는 클라이언트 간에 메시지 통신을 중개하는 메시지 **브로커broker**들이 나름의 API를 갖고 있어서 애플리케이션의 메시징 코드가 브로커 간에 호환될 수 없었다. 그러나 JMS를 사용하면 공통 인터페이스를 통해 함께 작동할 수 있다. <br>
스프링은 JmsTemplate이라는 템플릿 기반의 클래스를 통해 JMS를 지원한다. JmsTemplate을 사용하면 프로듀서(메시지 전송자)가 큐와 토픽에 메시지를 전송하고 컨슈머(메시지 수신자)가 메시지를 받을 수 있다. 또한, 스프링은 메시지 기반의 POJO도 지원한다. POJO는 큐나 토픽에 도착하는 메시지에 반응하여 비동기 방식으로 메시지를 수신하는 간단한 자바 객체이다. 

<br>

### 8.1.1 JMS 설정하기
JMS 클라이언트를 사용하려면 JMS 클라이언트를 우리 프로젝트의 빌드에 추가해야한다. <br>
만일 ActiveMQ를 사용할 것이라면 아래와 같이 의존성을 추가하면 된다.

```xml
	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-activemq</artifactId>
	</dependency>
```

그렇지 않고 ActiveMQ Artemis를 사용한다면 다음과 같이 지정해야한다.

```xml
	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-artemis</artifactId>
	</dependency>
```

Artemis는 ActiveMQ를 새롭게 다시 구현한 차세대 브로커이다. 우리 프로젝트에서는 Artemis를 사용할 것이다.<br>
기본적으로 스프링은 Artemis 브로커가 localhost의 6161 포트를 리스닝하는 것으로 간주한다. 그러나 실무 환경으로 애플리케이션을 개발 할 때는 몇가지 속성을 설정해야한다. <br>

**표 8.1 Artemis 브로커의 위치와 인증 정보를 구성하는 속성**

|속성|설명|
|---|---|
|spring.artemis.host|브로커의 호스트|
|spring.artemis.port|브로커의 포트|
|spring.artemis.user|브로커 사용하기 위한 ID (선택속성)|
|spring.artemis.password|브로커 사용하기 위한 Password (선택속성)|

<br>
application.yml을 작성하면 아래와 같다.
<br>

```xml
spring:
	artemis:
		host: artemis.tacocloud.com
		port: 61617
		user: tacoweb
		password: 12345
```

<br>

### 8.1.2 JmsTemplate을 사용해서 메시지 전송하기

JmsTemplate은 스프링 JMS 통합 지원의 핵심으로, 메시지 브로커와의 연결 및 세션을 생성하는 코드는 물론이고, 메시지를 전송하는 도중 발생할 수 있는 예오를 처리하는 수많은 코드도 우리가 작성해야한다. <br>
JmsTemplate은 다음을 비롯해서 메시지 전송에 유용한 여러 메서드를 갖고 있다.

```java
// 원시 메시지 전송
void send(MessageCreator messageCreator) throws JmsException;
void send(Detination destination, MessageCreator messageCreator) throws JmsException;
void send(String destinationName, MessageCreator messageCreator) throws JmsException;

//객체로부터 변환된 메시지를 전송한다.
void convertAndSend(Object message) throws JmsException;
void convertAndSend(Detination destination, Object message) throws JmsException;
void convertAndSend(String destinationName, Object message) throws JmsException;

//객체로부터 변환되고 전송에 앞서 후처리되는 메시지를 전송한다.
void convertAndSend(Object message, MessagePostProcessor postProcessor) throws JmsException;
void convertAndSend(Detination destination, Object message, MessagePostProcessor postProcessor) throws JmsException;
void convertAndSend(String destinationName, Object message, MessagePostProcessor postProcessor) throws JmsException;
```

* send() 메서드는 Message 객체를 생성하기 위해 MessageCreator 객체를 필요로 한다. 
* convertAndSend() 메서드는 Object 타입을 인자로 받아 내부적으로 Message 타입으로 변환한다.
* 후처리 하는 convertAndSend() 메서드는 메시지가 전송되기 전에 Message의 커스터마이징을 위한 MessagePostProcessor를 인자로 받는다.

* 각각의 첫 번째 메서드는 도착지 매개변수가 없으므로, 기본 도착지로 전송한다.
* 두 번째 메서드는 해당 메시지의 도착지를 나타내는 Destination 객체를 인자로 받는다.
* 세 번째 메서드는 해당 메시지의 도착지를 나타내는 문자열을 인자로 받는다.

기본적인 형태의 send() 메서드를 사용하는 코드는 아래와 같다.

**리스트 8.1 send()를 사용해서 주문 데이터 전송하는 JmsOrderMessagingService 클래스**

```java
@Service
public class JmsOrderMessagingService implement OrderMessagingService{
	private JmsTemplate jms;

	@Autowired
	public JmsOrderMessagingService(JmsTemplate jms){
		this.jms = jms;
	}

	@Override
	public void sendOrder(Order order) {
		jms.send(new MessageCreator() {
				@Override
				public Message createMessage(Session session) throws JMSException {
					return session.createObjectMessage(order);
				}
			}
		);
		//람다 식으로 표현하면 아래와 같다.
		//jms.send(session -> session.createObjectMessage(order));
	}
}
```

그러나 jms.send()는 메시지가 기본도착지로 가게 되어있어 기본 도착지를 지정해줘야 한다.

```xml
spring:
	jms:
		template:
				default-destination: tacocloud.order.queue
```

그러나 다른 도착지로 지정해야 하는 경우 아래와 같이 Destination 빈을 선언하여 메시지 전송을 수행하는 빈에 주입하면 된다.

```java
@Bean
public Destination orderQueue(){
	return new ActiveMQQueue("tacocloud.order.queue");
}
```

이 Destination 빈이 JmsOrderMessagingService에 주입되면 send()를 호출할 때 이 빈을 사용하여 메시지 도착지를 지정할 수 있다.

```java
@Service
public class JmsOrderMessagingService implement OrderMessagingService{
	private JmsTemplate jms;
	private OrderQueue orderQueue;

	@Autowired
	public JmsOrderMessagingService(JmsTemplate jms, Destination orderQueue){
		this.jms = jms;
		this.orderQueue = orderQueue;
	}

	@Override
	public void sendOrder(Order order) {
		jms.send(orderQueue, session -> session.createObjectMessage(order));
	}
}
```

다음처럼 String 형식으로도 보낼 수 있다.

```java
	@Override
	public void sendOrder(Order order) {
		jms.send("tacocloud.order.queue", session -> session.createObjectMessage(order));
	}
```

<br>

#### 메시지 변환하고 전송하기
JmsTemplate의 convertAndSend() 메서드는 MessageCreator를 제공하지 않아도 되므로 메시지 전송이 간단하다.

```java
	@Override
	public void sendOrder(Order order) {
		jms.convertAndSend("tacocloud.order.queue", order);
	}
```

#### 메시지 변환기 구현하기
MessageConverter는 스프링에 정의된 인터페이스이며 두 개의 메서드만 정의되어있다.

```java
public interface MessageConverter {
	Message toMessage(Object object, Session session) throws JMSException, MessageConversionException;
	Object fromMessage(Message message);
}
```

**표8.3 공통적인 변환 작업을 해주는 스프링 메시지 변환기**<br>
**(모두 org.springframework.jms.support.converter 패키지에 있음)**

|메시지 변환기|하는 일|
|---|---|
|MappingJackson2MessageConverter|Jackson2 JSON 라이브러리를 사용해서 메시지를 JSON으로 상호 변환한다.|
|MarshallingMessageConverter|JAXB를 사용해서 메시지를 XML로 상호 변환한다.|
|MessagingMessageConverter|수신된 MessageConverter를 사용해서 해당 메시지를 Message 객체로 상호 변환한다. 또는 JMS 헤더와 연관된 JmsHeaderMapper를 표준 메시지 헤더로 상호변환한다.|
|SimpleMessageConverter|문자열을 TextMessage로, byte 배열을 ByteMessage로, Map을 MapMessage로, Serializable 객체를 ObjectMessage로 상호 변환한다.|

다른 메시지 변환기를 적용할 때는 해당 변환기의 인스턴스를 빈으로 선언하면 된다.

```java
  @Bean
  public MappingJackson2MessageConverter messageConverter() {
    MappingJackson2MessageConverter messageConverter = new MappingJackson2MessageConverter();
    messageConverter.setTypeIdPropertyName("_typeId");
    
    return messageConverter;
  }
```

이 경우는 MappingJackson2MessageConverter의 setTypeIdPropertyName() 메서드를 호출한 후 이 메시지 변환기 인스턴스를 반환하는 것에 유의해야한다. 수신된 메시지 변환 타입을 메시지 수신자가 알아야 하기 때문에 이 부분이 매우 중요하다. 여기에는 변환되는 타입의 클래스 이름(패키지 전체 경로가 포함된)이 포함된다. 그러나 이것은 유연성이 다소 떨어진다. 메시지 수신자도 똑같은 클래스(패키지 전체 경로까지 동일한)와 타입을 가져야 하기 때문이다. <br>
따라서 유연성을 높이기 위해 메시지 변환기의 setTpeIdMappings()를 호출하여 실제 타입에 임의의 타입 이름을 매핑시킬 수 있다.

```java
  @Bean
  public MappingJackson2MessageConverter messageConverter() {
    MappingJackson2MessageConverter messageConverter =
                            new MappingJackson2MessageConverter();
    messageConverter.setTypeIdPropertyName("_typeId");
    
    Map<String, Class<?>> typeIdMappings = new HashMap<String, Class<?>>();
    typeIdMappings.put("order", Order.class);
    messageConverter.setTypeIdMappings(typeIdMappings);
    
    return messageConverter;
  }
```

이 경우 해당 메시지의 \_typeId 속성에 전송되는 클래스 이름 대신 order 값이 전송된다. 해당 메시지를 수신하는 애플리케이션에도 이와 유사한 메시지 변환기가 구성되어 있을 것이므로 order를 자신이 알고 있는 주문 데이터로 매핑하면 된다. <br>

#### 후처리 메시지
